

##########################################################################

### Function to project fire size metrics using power law distribution

### This assumes the distribution of fire sizes is e^-x (Malamud 2005)
### Takes cases with a mean or median, and takes 99.9th quantiles as min and max

##########################################################################

########################

### Need to sort out adding of rows to data frame so that it works

### Also, buckets should report buckets & numbers should report numbers

########################


estimate.metrics <- function(dat, metric = 'size', kind = 'estimated', 
                             actual = TRUE) {
  
  
  #######################################################################
  
  ### Function to make predictions on fire size based on exponential distribution
  
  ### Malamud et al., 2005
  
  ### https://en.wikipedia.org/wiki/Exponential_distribution
  
  #######################################################################
  
  dat.fill <- function(from, to) {
    
    ### Fill in meta data on prediction
    
    est_dat$Est.metric[nrow(est_dat)] <<- paste(ifelse(actual == TRUE,
                                                       'Actual', 'Intended'),to, sep = '.')
    
    est_dat$Based.on[nrow(est_dat)]   <<- paste(ifelse(actual == TRUE,
                                                       'Actual', 'Intended'),from, sep = '.')
    
    ##########################
    ### Calculate lambda
    ##########################
    
    
    if(kind == 'estimated') {
    
    if(from == 'mean') {
      
      lambda   <- 1/mean(as.numeric(c(gsub("\\-.*", "", ifelse(actual == FALSE, dat$`Intended.fire.size.mean.(ha)`[i], dat$`Actual.fire.size.mean.(ha)`[i])), 
                                      gsub(".*-", "", ifelse(actual == FALSE, dat$`Intended.fire.size.mean.(ha)`[i], dat$`Actual.fire.size.mean.(ha)`[i])))))
      
    } else if (from == 'median') {
      
      lambda   <- log(2) /mean(as.numeric(c(sub("\\-.*", "", ifelse(actual == FALSE, dat$`Intended.fire.size.median.(ha)`[i], dat$`Actual.fire.size.median.(ha)`[i])), 
                                            sub(".*-", "", ifelse(actual == FALSE, dat$`Intended.fire.size.median.(ha)`[i], dat$`Actual.fire.size.median.(ha)`[i])))))
      
    } else if (from == 'max') {
      
      lambda  <- -(log(0.01) /mean(as.numeric(c(sub("\\-.*", "", ifelse(actual == FALSE, dat$`Intended.fire.size.max.(ha)`[i], dat$`Actual.fire.size.max.(ha)`[i])), 
                                                sub(".*-", "", ifelse(actual == FALSE, dat$`Intended.fire.size.max.(ha)`[i], dat$`Actual.fire.size.max.(ha)`[i]))))))
      
    } else if (from == 'min') {
      
      lambda <- -(log(0.99) /mean(as.numeric(c(sub("\\-.*", "", ifelse(actual == FALSE, dat$`Intended.fire.size.min.(ha)`[i], dat$`Actual.fire.size.min.(ha)`[i])), 
                                               sub(".*-", "", ifelse(actual == FALSE, dat$`Intended.fire.size.min.(ha)`[i], dat$`Actual.fire.size.min.(ha)`[i]))))))
      
      }
      
    } else if (kind == 'reported') {
      
      if(from == 'mean') {
        
        lambda   <- 1/ ifelse(actual == FALSE, dat$`Intended.fire.size.mean.(ha)`[i], dat$`Actual.fire.size.mean.(ha)`[i])
        
      } else if (from == 'median') {
        
        lambda   <- log(2) /ifelse(actual == FALSE, dat$`Intended.fire.size.median.(ha)`[i], dat$`Actual.fire.size.median.(ha)`[i])
        
      } else if (from == 'max') {
        
        lambda  <- -(log(0.01) / ifelse(actual == FALSE, dat$`Intended.fire.size.max.(ha)`[i], dat$`Actual.fire.size.max.(ha)`[i]))
        
      } else if (from == 'min') {
        
        lambda <- -(log(0.99) / ifelse(actual == FALSE, dat$`Intended.fire.size.min.(ha)`[i], dat$`Actual.fire.size.min.(ha)`[i]))
        
      }
      
    }
    
    
    ##############################
    ### Make prediction
    ##############################
    
    if (to == 'mean') {
      
      return(1 / lambda)
      
    } else if (to == 'median') {
      
      return(log(2) / lambda)
      
    } else if (to == 'max') {
      
      return(qexp(0.99, lambda))
      
    } else if (to == 'min') {
      
      return(qexp(0.01, lambda))
      
    }
    
  }
  
  
  ####################################################################
  
  ### Function to update results frame as new rows are added
  
  ####################################################################
  
  update.rows <- function() {
    
    est_dat$Fire.creation.ID[nrow(est_dat)]  <<- dat$Fire.creation.ID[i]
    est_dat$Study.year[nrow(est_dat)]     <<- dat$Study.Year[i]
    est_dat$AFT[nrow(est_dat)]            <<- dat$AFT[i]
    est_dat$Fire.intention[nrow(est_dat)] <<- dat$Fire.intention[i]
    
    for (col in 1:length(key)) {
      
      est_dat[nrow(est_dat), 4+col] <<- key[col]
      
    }
    
    est_dat[nrow(est_dat)+1, ]            <<- NA
    update                                <<- TRUE
    
  }
  
  
  if(metric == 'size') {
    
    
    #####################################
    
    ### 1) Extract relevant data
    
    #####################################
    
    if(actual) {
    
      dat <- dat[apply(dat[, c(12, 14, 16, 18)], 1, function(x) {length(which(x > 0))}) >= 1, ]
    
    } else if (!actual) {
      
      dat <- dat[apply(dat[, c(11, 13, 15, 17)], 1, function(x) {length(which(x > 0))}) >= 1, ]
    }
    
    dat <- dat[dat$`Presence./.Absence` == 'Presence', ]
    
    
  }
  
  ### Set up results frame
  
  est_dat <- data.frame('Fire.creation.ID' = NA, 'AFT' = '', 'Fire intention' = '', 'Study.year' = '', 'Reported.Firemetric.1' = '', 
                        'Reported.Firemetric.2' = '', 'Reported.Firemetric.3' = '', 'Reported.Firemetric.4' = '',
                        'Reported.Firemetric.5' = '','Reported.Firemetric.6' = '','Based.on' = NA, 'Est.metric' = NA, 'Est.value' = NA)

    for(i in 1:nrow(dat)){
      
      if(i == 1) {
        
        est_dat[nrow(est_dat), ]                 <- NA
        est_dat$Fire.creation.ID[nrow(est_dat)]  <- dat$Fire.creation.ID[i]
        est_dat$Study.year[nrow(est_dat)]     <- dat$Study.Year[i]
        est_dat$AFT[nrow(est_dat)]            <- dat$AFT[i]
        est_dat$Fire.intention[nrow(est_dat)] <- dat$Fire.intention[i]
        
      }
      
      if(metric == 'size') {
        
        if(actual) {
        
        key <- colnames(dat)[c(12, 14, 16, 18)][which(!is.na(dat[i, c(12, 14, 16, 18)]))]
        
        } else if (!actual) {
          
        key <- colnames(dat)[c(11, 13, 15, 17)][which(!is.na(dat[i, c(11, 13, 15, 17)]))]
          
          
        }
        
        for (col in 1:length(key)) {
          
          est_dat[nrow(est_dat), 4+col] <- key[col]
          
        }
        
        ################################################
        
        ### 2) get information on what fire data is available
        
        ###############################################
        
        update     <- FALSE
        
        has.mean   <- any(TRUE %in% grepl('mean', est_dat[nrow(est_dat), 4:7]))
        has.median <- any(TRUE %in% grepl('median', est_dat[nrow(est_dat), 4:7]))
        has.min    <- any(TRUE %in% grepl('min', est_dat[nrow(est_dat), 4:7]))
        has.max    <- any(TRUE %in% grepl('max', est_dat[nrow(est_dat), 4:7]))

        
        #################################################################
        
        ### 3) Fill metrics
        
        #################################################################
        
        ### use mean
        
        if(has.mean) {
        
          #if(!has.median) {
          
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'mean', to = 'median')
            update.rows()
          
          #}
          
          #if(!has.max) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'mean', to = 'max')
            update.rows()
            
          #}
          
          #if(!has.min) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'mean', to = 'min')
            update.rows()
            
          #}
            
        }
        
        
        ### use median
        
        if(has.median) {
        
          #if(!has.mean) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'median', to = 'mean')
            update.rows()
            
          #}
          
          #if(!has.max) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'median', to = 'max')
            update.rows()
            
          #}
          
          #if(!has.min) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'median', to = 'min')
            update.rows()
            
          #}
          
          
        }
        
        #if(has.max & !has.median) {
          
          est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'max', to = 'median')
          update.rows()
          
        #}
        
        
        ### Use max
        
        if(has.max) {
        
          #if(!has.mean) {
          
          est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'max', to = 'mean')
          update.rows()
          
          #}
          
          #if(!has.median) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'max', to = 'median')
            update.rows()
            
          #}
          
          #if(!has.min) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'max', to = 'min')
            update.rows()
            
          #}
          
        }
        
        ### Use min
        
        if(has.min) {
          
          #if(!has.mean) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'min', to = 'mean')
            update.rows()
            
          #}
          
          #if(!has.median) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'min', to = 'median')
            update.rows()
            
          #}
          
          #if(!has.max) {
            
            est_dat$Est.value[nrow(est_dat)]  <- dat.fill(from  = 'min', to = 'max')
            update.rows()
            
          #}
          
        }
        
        ##### Catch cases where no update was made

        if (update == FALSE) {
          
          est_dat$Fire.creation.ID[nrow(est_dat)]  <- dat$Fire.creation.ID[i]
          est_dat$Study.year[nrow(est_dat)]     <- dat$Study.Year[i]
          est_dat$AFT[nrow(est_dat)]            <- dat$AFT[i]
          est_dat$Fire.intention[nrow(est_dat)] <- dat$Fire.intention[i]
          
          for (col in 1:length(key)) {
            
            est_dat[nrow(est_dat), 4+col] <- key[col]
            
          }
          
          
          est_dat[nrow(est_dat)+1, ]                <- NA
          
        }
        
      }
      
    }
    
  return(est_dat)  
  
  
}



###########################################################

### Testing of outputs

###########################################################

intended.estimated <- estimate.metrics(est_fire, actual = F, kind = 'estimated')
intended.reported  <- estimate.metrics(reported_fire, actual = F, kind = 'reported')

actual.estimated   <- estimate.metrics(est_fire, actual = T, kind = 'estimated')
actual.reported    <- estimate.metrics(reported_fire, actual = T, kind = 'reported')



#### merge predicted and actual values

dict            <- list('Actual.median' = "Actual.fire.size.median.(ha)", 
                        'Intended.median' = "Intended.fire.size.median.(ha)", 
                        'Actual.mean' = "Actual.fire.size.mean.(ha)", 
                        'Intended.mean' = "Intended.fire.size.mean.(ha)", 
                        'Actual.max' = "Actual.fire.size.max.(ha)", 
                        'Intended.max' = "Intended.fire.size.max.(ha)", 
                        'Actual.min' = "Actual.fire.size.min.(ha)", 
                        'Intended.min' = "Intended.fire.size.min.(ha)")



intended.reported$data <- NA

for(i in 1:nrow(intended.reported)) {
  
  val <- as.numeric(reported_fire[which(reported_fire$Fire.creation.ID == intended.reported$Fire.creation.ID[i]), 
                                         which(colnames(reported_fire) == as.character(dict[intended.reported$Est.metric[i]]))])
  
  
  intended.reported$data[i] <- ifelse(length(val) == 1, val , NA)
  
}

intended.reported <- intended.reported[!is.na(intended.reported$Est.value) & !is.na(intended.reported$data), ]

#####################################################################################
### actual reported
#####################################################################################


actual.reported$data <- NA

for(i in 1:nrow(actual.reported)) {
  
  val <- as.numeric(reported_fire[which(reported_fire$Fire.creation.ID == actual.reported$Fire.creation.ID[i]), 
                                  which(colnames(reported_fire) == as.character(dict[actual.reported$Est.metric[i]]))])
  
  
  actual.reported$data[i] <- ifelse(length(val) == 1, val , NA)
  
}

actual.reported <- actual.reported[!is.na(actual.reported$Est.value) & !is.na(actual.reported$data), ]


#############################################
### estimated reported
#############################################


actual.estimated$data <- NA

for(i in 1:nrow(actual.estimated)) {
  
  val <- as.character(est_fire[which(est_fire$Fire.creation.ID == actual.estimated$Fire.creation.ID[i]), 
                                  which(colnames(est_fire) == as.character(dict[actual.estimated$Est.metric[i]]))])
  
  
  actual.estimated$data[i] <- ifelse(length(val) == 1, val , NA)
  
}

actual.estimated         <- actual.estimated[!is.na(actual.estimated$Est.value) & !is.na(actual.estimated$data), ]
actual.estimated$Firebin <- bin.vals(actual.estimated$Est.value)

Metrics::accuracy(actual.estimated$data[!actual.estimated$Based.on %in% c('Actual.median', 'Actual.mean')],
                  actual.estimated$Firebin[!actual.estimated$Based.on %in% c('Actual.median', 'Actual.mean')])


###########################################################

### Intended estimated

###########################################################

intended.estimated$data <- NA

for(i in 1:nrow(intended.estimated)) {
  
  val <- as.character(est_fire[which(est_fire$Fire.creation.ID == intended.estimated$Fire.creation.ID[i]), 
                               which(colnames(est_fire) == as.character(dict[intended.estimated$Est.metric[i]]))])
  
  
  intended.estimated$data[i] <- ifelse(length(val) == 1, val , NA)
  
}

intended.estimated         <- intended.estimated[!is.na(intended.estimated$Est.value) & !is.na(intended.estimated$data), ]
intended.estimated$Firebin <- bin.vals(intended.estimated$Est.value)

Metrics::accuracy(intended.estimated$data[!intended.estimated$Based.on %in% c('Intended.median', 'Intended.mean')],
                  intended.estimated$Firebin[!intended.estimated$Based.on %in% c('Intended.median', 'Intended.mean')])


##########################################################

### merge and compare estimated outputs

##########################################################

### Visualisation

power.estimates <- estimate.metrics(reported_fire, actual = T, kind = 'reported')

power.sum <- power.estimates[-nrow(power.estimates), ] %>% 
  group_by(.dots = c('AFT', 'Fire.intention', 'Est.metric', 'Based.on')) %>%
    summarise('Mean_est' = median(Est.value, na.rm = T), 
              'Upper' = quantile(Est.value, 0.975, na.rm = T), 
              'Lower' = quantile(Est.value, 0.025, na.rm = T))

ggplot(power.sum[power.sum$Est.metric == 'Actual.mean', ], aes(x = AFT, fill = Fire.intention, y = Mean_est)) + facet_grid(Based.on~.) +
  geom_col(position = position_dodge(), colour = 'black') + scale_y_sqrt(breaks = c(0, 2.5, 10, 100, 500, 1000, 2000)) + 
  theme_classic() + scale_fill_viridis_d() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + ylab('Fire size (ha)') +
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 1, position = position_dodge())


est_extrap      <- est_fire
dict            <- list('Actual.median' = (which(colnames(est_extrap) == "Actual.fire.size.median.(ha)")), 
                        'Intended.median' = (which(colnames(est_extrap) == "Intended.fire.size.median.(ha)")))

for (i in 1:nrow(power.estimates)) {
  
  r <- which(est_extrap$Case.Study.ID == power.estimates$Case.Study.ID[i] & 
               est_extrap$AFT == power.estimates$AFT[i] & 
               est_extrap$Fire.intention == power.estimates$Fire.intention[i])
  
  est_extrap[r, as.numeric(dict[power.estimates$Est.metric[i]])] <- power.estimates$Est.value[i]
  
  print(i)
  
}

lambda  <- -(log(0.02) / 1000) 
lambda2 <- -(log(0.14) / 50)
